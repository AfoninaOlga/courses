== Процессоры RISC-V

В этой главе вы познакомитесь с различными терминами, используемыми в экосистеме RISC-V, а затем узнаете о RISC-V ISA.
Будут подробно описаны несколько вариантов ISA.

Далее мы проанализируем, как можно использовать процессор RISC-V, построенный с использованием ISA.
Вы также увидите, как различные инструменты RISC-V могут быть использованы для создания простых примеров приложений.

После прочтения данной главы вы будете:

* понимать терминологию RISC-V;
* уметь следовать набору инструкций RISC-V;
* уметь использовать процессоры RISC-V;
* уметь использовать инструменты RISC-V для создания простых приложений.

=== Знакомство с RISC-V

==== Что представляет собой RISC-V?

RISC-V -- это новая архитектура наборов команд (ISA), которая изначально была определена для поддержки образования и исследований в области компьютерной архитектуры,
но теперь превратилась в свободный стандарт и открытую архитектуру, принятую в промышленности для создания собственных процессоров.

Ниже перечислены цели определения RISC-V, как они определены в https://riscv.org/technical/specifications/[спецификациях RISC-V].
Конкретным документом, в котором перечислены эти цели, является https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-54.pdf[технический отчет UCB/EECS-2014-54].

* Полностью _открытая_ ISA, свободно доступная для академических и промышленных кругов.
* _Настоящая_ ISA, пригодная для прямой аппаратной реализации, а не только для моделирования или двоичной трансляции.
* ISA, которая позволяет избежать «избыточной архитектуры» для определенного стиля микроархитектуры
(например, микрокодированной, упорядоченной, развязанной, неупорядоченной) или технологии реализации (например, full-custom, ASIC, FPGA), но позволяет эффективно реализовать любую из них.
* ISA, разделенная на _небольшой_ базовый целочисленная ISA, используемая сама по себе в качестве основы для специализированных ускорителей или в образовательных целях,
и дополнительные стандартные расширения для поддержки разработки программного обеспечения общего назначения.
* Поддержка пересмотренного стандарта плавающей запятой IEEE-754 2008 года.
* ISA, поддерживающая обширные расширения на уровне пользователя и специализированные варианты.
* Как 32-битовые, так и 64-битовые варианты адресного пространства для приложений, ядер операционных систем и аппаратных реализаций.
* ISA с поддержкой высоко параллельных многоядерных (multicore) или многоядерных (manycore) реализаций, включая гетерогенные мультипроцессоры.
* Дополнительные _инструкции переменной длины_ для расширения доступного пространства кодирования инструкций
и поддержки дополнительного _плотного кодирования инструкций_ для повышения производительности, статического размера кода и энергоэффективности.
* Полностью виртуализируемая ISA для облегчения разработки гипервизоров.
* ISA, которая упрощает эксперименты с новыми конструкциями ISA на уровне супервизора и гипервизора.

Спецификация максимально избегает определения деталей реализации, поэтому её можно рассматривать как программно-видимый интерфейс для широкого спектра аппаратных реализаций,
а не для конкретной аппаратной реализации.

Спецификация разделена на два тома: один определяет «базовые непривилегированные» инструкции, а другой -- «классические привилегированные» возможности RISC-V.

В следующих разделах дается базовое представление о проектировании непривилегированной ISA, при необходимости вы можете обратиться к привилегированным спецификациям.

==== Терминология аппаратной платформы RISC-V

Аппаратная платформа RISC-V может содержать одно или несколько RISC-V-совместимых вычислительных ядер, а также другие (несовместимые с RISC-V) ядра,
ускорители с фиксированной функциональностью, различные физические структуры памяти, устройства ввода-вывода и структуру межсоединений, которая позволяет компонентам взаимодействовать.

Компонент называется _ядром_, если он содержит независимый блок выборки инструкций (IFU).
RISC-V-совместимое ядро может поддерживать несколько RISC-V-совместимых аппаратных потоков, или hart’ов (hardware threads), посредством многопоточности.

Ядро RISC-V может иметь дополнительные специализированные расширения набора инструкций или дополнительный _сопроцессор_.

Термин сопроцессор используется для обозначения блока, который присоединен к ядру RISC-V и в основном управляется потоком инструкций RISC-V,
но содержит дополнительное архитектурное состояние и расширения набора инструкций, а также, возможно, имеет ограниченную автономность относительно основного потока инструкций RISC-V.

Термин _ускоритель_ относится либо к непрограммируемому блоку с фиксированной функциональностью, либо к ядру, которое может работать автономно, но специализировано для определенных задач.
В системах на базе RISC-V может быть много программируемых ускорителей,
которые представляют собой ядра на базе RISC-V со специализированными расширениями набора инструкций и/или настроенными сопроцессорами.
I/O-ускорители являются важным классом ускорителей на базе RISC-V; они выполняют задачи обработки ввода-вывода, снимая нагрузку с основных ядер приложений.

Системный уровень структуры аппаратной платформы на базе RISC-V может варьироваться от микроконтроллера с одним ядром до кластера из тысяч многоядерных серверных узлов с общей памятью.
Даже маленькие системы на одном кристалле могут быть структурированы как иерархия мультикомпьютеров
и/или мультипроцессоров для модульного подхода к разработке или для обеспечения безопасной изоляции между подсистемами.

Дополнительные сведения можно найти в https://riscv.org/technical/specifications/[спецификациях RISC-V].

==== Среды выполнения программного обеспечения RISC-V и hart’ы

Среда выполнения, в которой выполняется программа на RISC-V, определяет её поведение.
Интерфейс среды выполнения (EEI) RISC-V определяет начальное состояние программы, а также количество и тип hart’ов,
с которыми может работать среда, включая режимы привилегий, поддерживаемые этими потоками.

EEI также определяет доступность и атрибуты областей памяти и ввода-вывода, поведение каждого hart’а для всех допустимых инструкций,
выполняемых на нём (т.е. ISA является одним из компонентов EEI), и обработку любых прерываний или исключений, возникающих во время выполнения, включая вызовы окружения.

Примеры EEI включают двоичный интерфейс приложений Linux (ABI) и двоичный интерфейс супервизора RISC-V (SBI).
Среда выполнения RISC-V может быть реализована как чисто аппаратная, как чисто программная или как комбинация аппаратной и программной частей.
Например, ловушки опкодов и программная эмуляция могут быть использованы для реализации функциональности, не предусмотренной в аппаратном обеспечении.

Примеры реализации среды выполнения включают (взято из спецификаций RISC-V):

* Аппаратные платформы «голого железа», где hart’ы напрямую реализуются потоками физического процессора, а инструкции имеют полный доступ к физическому адресному пространству.
** В этой реализации аппаратная платформа определяет среду выполнения, которая начинается при сбросе при включении питания.
* Операционные системы RISC-V, обеспечивающие несколько сред выполнения на уровне пользователя.
** В этой модели среды обеспечиваются путем мультиплексирования задач пользовательского уровня на доступные потоки физического процессора и управления доступом к памяти через виртуальную память.
* Гипервизоры RISC-V, обеспечивающие несколько сред выполнения на уровне супервизора для гостевых операционных систем.
* Эмуляторы RISC-V, такие как Spike, QEMU или rv8.
** Они эмулируют hart’ы RISC-V на базовой системе x86 и могут предоставлять среду выполнения на уровне пользователя или супервизора.

С точки зрения программного обеспечения, работающего в данной среде выполнения, hart -- это ресурс, который автономно извлекает и выполняет инструкции RISC-V в этой среде.
В этом отношении hart ведет себя как ресурс аппаратного потока, даже если он мультиплексирован по времени на реальное оборудование средой выполнения.
Некоторые EEI поддерживают создание и уничтожение дополнительных hart’ов, например, через вызовы среды для создания новых hart’ов.

Среда выполнения отвечает за обеспечение возможного продвижения вперед каждого из своих hart’ов.
Для данного потока эта ответственность приостанавливается, пока он выполняет механизм, который явно ожидает события,
например, инструкцию wait-for-interrupt, и эта ответственность заканчивается, если поток завершается.
Следующие события представляют собой продвижение вперед:

* упразднение инструкции;
* ловушка;
* любое другое событие, определяемое расширением как представляющее собой дальнейший прогресс.

=== Архитектура набора инструкций RISC-V

ISA RISC-V разделена на две части.
Одна часть -- это базовая целочисленная ISA, которую должны поддерживать все реализации процессора.
Вторая -- дополнительный набор инструкций, которые могут поддерживаться как расширенные инструкции.
Поддержка расширенных инструкций является необязательной.

==== Базовая целочисленная ISA

База ограничена минимальным набором инструкций, достаточным для поддержки существующих компиляторов,
ассемблеров, компоновщиков и операционных систем (с дополнительными привилегированными инструкциями).
Поэтому база обеспечивает простую и удобную отправную точку для создания пользовательских процессоров, с дополнительными специализированными ISA по мере необходимости.

На самом деле существует четыре базовых ISA, которые образуют семейство RISC-V ISA.
Они делятся на категории в зависимости от размера целочисленных регистров, соответствующего размера адреса и количества целочисленных регистров.

Ниже перечислены ISA, определенные как часть семейства RISC-V ISA.

* RV32I -- первичная ISA, с поддержкой 32-битовых адресов.
* RV64I -- основная ISA, с поддержкой 64-битовых адресов.
* RV32E -- подмножество RV32I, определенное для небольших микроконтроллеров с вдвое меньшим количеством регистров.
* RV128I -- будущая ISA с поддержкой 128-битовой адресации.

Структура ISA была тщательно продумана. Более подробную информацию об обосновании этого можно найти в спецификации RISC-V.

ISA были разработаны для широкой настройки и специализации.
Каждая конкретная ISA была определена таким образом, что она может быть расширена одной или несколькими инструкциями по мере необходимости.
Пространство кодирования набора инструкций RISC-V и связанные с ним пространства кодирования, такие как регистры управления и состояния (CSR),
разделены на три несовпадающие категории: стандартные, зарезервированные и пользовательские.

Стандартные кодировки определяются Фондом и не должны конфликтовать с другими стандартными расширениями для той же базовой ISA.

Зарезервированные кодировки в настоящее время не определены, но сохранены для будущих расширений стандарта.

Пользовательские кодировки доступны для нестандартных расширений, специфичных для конкретного производителя, и никогда не должны использоваться для стандартных расширений.
Нестандартные расширения не определены Фондом.

Термин «_несоответствующий_» используется для описания нестандартного расширения, которое использует либо стандартную,
либо зарезервированную кодировку (то есть пользовательские расширения не являются несоответствующими).
Расширения набора инструкций, как правило, являются общими, но могут обеспечивать несколько иную функциональность в зависимости от базовой ISA.

Ниже приведен список ISA, определенных базовыми спецификациями ISA.
Чтобы получить определение соответствующей ISA, к каждому из следующих имен добавьте RV32 или RV64.

* I -- базовая целочисленная ISA
* M -- стандартные целочисленные расширения умножения и деления
* A -- стандартные целочисленные атомарные расширения (атомарное чтение, изменение и запись в память для синхронизации)
* F -- регистры с плавающей запятой (вычислительные инструкции с одинарной точностью, загрузка и сохранение)
* D -- регистры с плавающей запятой двойной точности (вычислительные инструкции двойной точности, загрузка и сохранение)
* C -- сжатые инструкции (обеспечивают более узкие 16-битовые версии базовых инструкций)

Почти все приложения могут работать с определенным набором стандартных инструкций, но есть определенные приложения,
для которых очень полезны специальные инструкции, определенные для данного приложения.

RISC-V будет стремиться сохранить базовые инструкции и стандартные расширения неизменными с течением времени, а любые новые требования будут добавляться в качестве дополнительных расширений. Например, базовая целочисленная ISA будет существовать как отдельная ISA, независимо от любых расширений, которые будут добавляться время от времени.

==== Краткое описание инструкций RISC-V

Ниже приводится краткое описание различных типов команд и их определения в спецификациях RISC-V. Это форматы 32-битовых инструкций RISC-V:

.Типы инструкций
[width="100%",cols="5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1",options="header",]
|===
|Тип |[.small]#31# |[.small]#30# |[.small]#29# |[.small]#28# |[.small]#27# |[.small]#26# |[.small]#25# |[.small]#24# |[.small]#23# |[.small]#22# |[.small]#21# |[.small]#20# |[.small]#19# |[.small]#18# |[.small]#17# |[.small]#16# |[.small]#15# |[.small]#14# |[.small]#13# |[.small]#12# |[.small]#11# |[.small]#10# |[.small]#9# |[.small]#8# |[.small]#7# |[.small]#6# |[.small]#5# |[.small]#4# |[.small]#3# |[.small]#2# |[.small]#1# |[.small]#0#
|Регистр/регистр +(R)+ 7+^|funct7 5+^|rs2 5+^|rs1 3+^|funct3 5+^|rd 7+^|код операции

|С операндом (I) 12+^|imm[11:0] 5+^|rs1 3+^|funct3 5+^|rd 7+^|код операции

|С длинным операндом (U) 20+^|imm[31:12] 5+^|rd 7+^|код операции

|Сохранение (S) 7+^|imm[11:5] 5+^|rs2 5+^|rs1 3+^|funct3 5+^|imm[4:0] 7+^|код операции

|Ветвление (B) 7+^|[12] imm[10:5] 5+^|rs2 5+^|rs1 3+^|funct3 5+^|imm[4:1] [11] 7+^|код операции

|Переход (J) 7+^|[20] imm[10:1] 5+^|[11] 7+^|imm[19:12] 5+^|rd 7+^|код операции
|===

* код операции (7 бит): частично определяет один из 6 типов форматов инструкций.
Чтобы узнать больше, см. следующую https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8[статью Википедии].
* `funct7` и `funct3` (10 бит): в комбинации дополнительно указывают выполняемую операцию.
* `rs1` (5 бит): определяет по индексу регистр-источник, содержащий первый операнд.
* `rs2` (5 бит): указывает регистр источника, содержащий второй операнд.
* `rd` (5 бит): указывает регистр назначения, в который будет направлен результат вычислений.

RISC-V ISA определяет необходимый набор регистров, которые должны быть реализованы в процессоре,
так что программное обеспечение во всех реализациях видит один и тот же набор регистров процессора.

Ниже приведен список регистров. Из этой таблицы можно понять, какие регистры необходимы в процессоре RISC-V.
Как разработчик, вы должны уметь эффективно использовать эти регистры для создания приложений.

:link-integer-registers: https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BB%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE[целочисленных]
:link-floating-registers: https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9[плавающей запятой]

.Список регистров
[width="100%",cols="^25%,^25%,^25%,^25%",options="header",]
|===
|Имя регистра в RISC-V |Псевдоним |Описание |Кто сохраняет
4+|32 {link-integer-registers} регистра

|x0 |Zero |всегда ноль |

|x1 |ra |https://en.wikipedia.org/wiki/Return_statement[Адрес возврата] |Вызывающий

|x2 |sp |https://en.wikipedia.org/wiki/Call_stack#STACK-POINTER[Указатель стека] |Вызываемый

|x3 |gp
|http://tool-support.renesas.com/autoupdate/support/onlinehelp/csp/V4.01.00/CS+.chm/Compiler-CCRH.chm/Output/ccrh08c0401y.html#:~:text=8.4.1%20Global%20pointer%20(gp,PID%3A%20Position%20Independent%20Data)[Глобальный указатель]
|

|x4 |tp |https://en.wikipedia.org/wiki/Thread-local_storage[Потоковый указатель] |

|x5 |t0 |Temporary/альтернативный адрес возврата |Вызывающий

|x6-7 |t1-2 |Temporary |Вызывающий

|x8 |s0/fp |Saved register / frame pointer |Вызываемый

|x9 |s1 |Saved register |Вызываемый

|x10-11 |a0-1 |Аргумент / возвращаемое значение |Вызывающий

|x12-17 |a2-7 |Аргумент |Вызывающий

|x18-27 |s2-11 |Saved register |Вызываемый

|x28-31 |t3-6 |Temporary |Вызывающий

4+|32 дополнительных регистра с {link-floating-registers}

|f0-7 |ft0-7 |Floating-point temporaries |Вызывающий

|f8-9 |fs0-1 |Floating-point saved registers |Вызываемый

|f10-11 |fa0-1 |Floating-point arguments / Return values |Вызывающий

|f12-17 |fa2-7 |Floating-point arguments |Вызывающий

|f18-27 |fs2-11 |Floating-point saved registers |Вызываемый

|f28-31 |ft8-11 |Floating-point temporaries |Вызывающий
|===

Для реализаций процессоров, не поддерживающих расширения с плавающей запятой, не нужно определять регистры с плавающей запятой.

==== Память

Харт RISC-V имеет единое адресное пространство размером stem:[2^{XLEN}] байт для всех обращений к памяти, где XLEN -- ширина инструкции (например, для RV32 XLEN равен 32).

Слово памяти определяется как 32 бита (4 байта).
Соответственно, _полуслово_ -- 16 бит (2 байта), _двойное слово_ -- 64 бита (8 байт), а _четверное слово_ -- 128 бит (16 байт).
Адресное пространство памяти является кольцевым; следовательно, байт по адресу stem:[$2^{XLEN}-1$] является соседним с байтом по адресу ноль.
Соответственно, вычисления адресов памяти, выполняемые аппаратным обеспечением, игнорируют переполнение и вместо этого преобразуются в значения по модулю stem:[$2^{XLEN}$].

Среда выполнения определяет отображение аппаратных ресурсов в адресное пространство hart’а.
Различные диапазоны адресов адресного пространства hart’а могут:

* быть свободными;
* содержать основную память;
* содержать одно или несколько устройств ввода-вывода.

Чтение и запись в устройства ввода-вывода могут иметь видимые побочные эффекты, но доступ к основной памяти -- нет.
Хотя среда выполнения может называть устройством ввода-вывода все, что находится в адресном пространстве hart’а, обычно ожидается, что некоторая часть будет указана как основная память.

Когда процессор имеет более одного hart’а:

* адресное пространство может быть уникальным для каждого из hart’ов;
* оно может быть одинаковым для обоих hart’ов;
* некоторые части могут быть общими, а другие -- уникальными для каждого из них.

Выполнение каждой машинной инструкции в RISC-V приводит к одному или нескольким явным или неявным обращениям к памяти.
Для каждой выполненной инструкции существует по крайней мере один неявный доступ к памяти -- это операция `fetch` выборки инструкции,
которая инструктирует процессор о том, что должно быть выполнено.
Ряд инструкций RISC-V не требует дополнительных неявных обращений к памяти, кроме `fetch`’а,
поскольку вся информация, необходимая процессору для выполнения операции, закодирована в `fetch`’е.
Существуют также специальные инструкции `load и `store`, которые выполняют явный доступ к памяти, обращаясь к требуемому местоположению как часть инструкции.
Механизм выполнения может предписывать дополнительные неявные обращения к памяти, например,
для выполнения трансляции адреса, но это не определено в спецификации RISC-V и зависит от конкретной реализации.

Среда выполнения определяет, какая часть памяти доступна для того или иного типа доступа к памяти.
На основании этого определения некоторые части памяти не могут быть доступны для определенной операции,
и любая попытка доступа к этим местам приведет к тому, что процессор выдаст исключение для этой инструкции.
Свободные места в адресном пространстве никогда не доступны.

Если не указано иное, неявные чтения, которые не вызывают исключений и не имеют побочных эффектов, могут происходить произвольно,
рано и спекулятивно, даже до того, как машина сможет доказать, что чтение будет необходимо.
Например, допустимая реализация может попытаться прочитать всю основную память при первой же возможности,
кэшировать как можно больше доступных для выборки (исполняемых) байтов для последующих выборок инструкций и никогда больше не читать основную память для выборок инструкций.
Чтобы гарантировать, что определенные неявные чтения упорядочены только после записи в те же области памяти,
программное обеспечение должно выполнять определенные инструкции ограничения или управления кэшем, определенные для этой цели, такие как инструкция `FENCE.I`.

RISC-V определяет модель упорядочивания памяти, которая является слабой моделью упорядочивания памяти.
Модель согласованности памяти по умолчанию для RISC-V -- это RISC-V Weak Memory Ordering (RVWMO).
Эта модель определена как часть спецификаций. Альтернативная сильная модель также определена в спецификациях,
и реализация может выбрать поддержку этой модели упорядочивания вместо слабой модели памяти.

==== Кодирование длины инструкции

Длина базовой инструкции RISC-V составляет 32 бита.
Однако схема кодирования стандартной длины предназначена для поддержки кодирования инструкции переменной длины.
Расширенные инструкции могут содержать любое количество 16-битовых посылок, выровненных по 16-битовой границе.

Стандартный сжатый ISA обеспечивает сжатую форму инструкций шириной 16 бит, что может привести к уменьшению размера кода.
Это также ослабляет ограничения на выравнивание инструкций и позволяет выравнивать все инструкции по 16-битовой границе
(как для 16-битовых, так и для 32-битовых инструкций), что приводит к улучшению плотности кода.

Более подробную информацию о кодировании ISA с переменной длиной можно найти в https://riscv.org/technical/specifications/[базовых спецификациях RISC-V].

==== Поддержка инструкций Endian

Базовые ISA RISC-V имеют либо _little-endian_, либо _big-endian_ системы памяти, а привилегированная архитектура дополнительно определяет _bi-endian_ операции.
Инструкции хранятся в памяти в виде последовательности 16-битовых посылок в little-endian, независимо от «эндианальности» системы памяти.
Посылки, образующие одну инструкцию, хранятся по возрастающим адресам в полслова,
причем самая младшая посылка содержит младшие биты в спецификации инструкции (как сказано в спецификаций RISC-V).

=== Исключения, прерывания и ловушки

В этом разделе мы обсудим, как RISC-V обрабатывает исключения и прерывания.

Исключения -- это необычные условия, связанные с инструкцией в текущем RISC-V hart’е, которые могут возникнуть во время выполнения.
Прерывания -- это внешние асинхронные события, которые могут привести к неожиданной передаче управления RISC-V hart.
Ловушки означают передачу управления обработчику ловушек, вызванную либо исключением, либо прерыванием.

То, как ловушки обрабатываются и становятся видимыми для программ, работающих на hart’е, зависит от окружающей среды выполнения.
С точки зрения программ, работающих в этой среде выполнения, ловушки, с которыми сталкивается hart во время выполнения, могут иметь четыре различных эффекта:

* _Содержащаяся ловушка_
+
Этот тип ловушек виден и обрабатывается программным обеспечением, работающим в EEI.
Например, в случае, когда и пользовательский режим, и режим супервизора на hart'ах обрабатываются EEI, ECALL hart'а,
работающего в пользовательском режиме, приведет к передаче управления обработчику режима супервизора, работающему на том же hart'е.
* _Запрошенная ловушка_
+
Когда синхронное исключение возникает в результате явного вызова среды выполнения, требующего действия от программного обеспечения в среде выполнения, это называется запрошенной ловушкой.
Примером может служить системный вызов.
В этом случае выполнение может возобновиться или не возобновиться после того, как программное обеспечение в среде выполнения выполнит запрошенное действие.
* _Невидимая ловушка_
+
Этот тип ловушки обрабатывается средой выполнения прозрачным образом, и выполнение программы возобновляется в обычном режиме после обработки ловушки.
Примеры включают эмуляцию отсутствующих инструкций, обработку ошибок нерезидентных страниц в системе виртуальной памяти,
работающей по требованию, и обработку прерываний устройства для другого задания в многопрограммной машине.
* _Фатальная ловушка_
+
Фатальные ловушки представляют собой фатальный сбой в системе и вызывают завершение выполнения программы.
В качестве примера можно привести сбой проверки защиты страниц виртуальной памяти или истечение срока действия сторожевого таймера.
Каждый EEI должен определить, как завершается выполнение и как об этом сообщается во внешнюю среду.

Способ обработки каждой ловушки определяется EEI; рекомендация заключается в точной обработке ловушек, но EEI может решить обрабатывать их иначе.
Некоторые ловушки, такие как содержащиеся и запрашиваемые ловушки, наблюдаются программным обеспечением EEI как неточные.
Невидимые ловушки по определению не могут быть замечены, независимо от того, являются ли они точными или неточными.
Ловушки редко упоминаются в первом томе спецификации RISC-V, поскольку в этом документе подробно описаны непривилегированные инструкции.

Архитектурные средства обработки содержащихся ловушек описаны в руководстве по привилегированной архитектуре, наряду с другими возможностями.
Непривилегированные инструкции, которые определены исключительно для того, чтобы вызывать запрошенные ловушки, также документированы там.
Невидимые ловушки по своей природе выходят за рамки данного курса.

Кодировки инструкций, не определенные в спецификациях RISC-V ISA и не определенные каким-либо другим способом, могут привести к фатальной ловушке.

=== Неопределённое поведение и неопределённые значения

Спецификация и архитектура полностью описывают, что должны делать реализации, а также любые ограничения на то, что они могут делать.
Если архитектура не определяет поведение в явном виде, то это поведение определяется как `UNSPECIFIED`.

Поведение или значения UNSPECIFIED намеренно оставлены неограниченными, чтобы они могли быть определены в расширениях, стандартах платформы или других реализациях.
Кроме того, если есть неограниченные определения, они также должны быть определены как `UNSPECIFIED`.
При необходимости эти значения могут быть расширены или определены позже.

Список инструкций в RISC-V ISA и соответствующих расширений базовой ISA см. в
https://www.cl.cam.ac.uk/teaching/1617/ECAD+Arch/files/docs/RISCVGreenCardv8-20151013.pdf[справочной карте] RISC-V.

==== Инструкции, относящиеся к CSR

RISC-V определяет инструкции, специфичные для CSR, и имеет отдельное адресное пространство для CSR для каждого hart’а процессора.
Это адресное пространство имеет размер 4096.
Все инструкции CSR атомарно читаю/модифицируют/записывают один CSR, спецификатор которого закодирован в 12-битном поле csr инструкции, расположенном в битах 31-20.
Непосредственные формы используют 5-битное, расширенное до нуля непосредственное значение, закодированное в поле rs1.

=== Процессоры RISC-V

Экосистема процессоров RISC-V быстро развивается.
Существуют как открытые, так и коммерческие предложения процессоров RISC-V.
Список доступных процессоров можно найти на https://github.com/riscvarchive/riscv-cores-list[GitHub].

Помимо списка доступных для использования ядер, существуют также готовые чипы и системы на кристалле (SoC), построенные на базе процессоров RISC-V.
Различные крупные компании, производящие чипы, такие как NVIDIA и Western Digital, использовали RISC-V в своих продуктах.

Кроме того, на момент создания этого курса планируется выпуск плат, построенных на базе процессоров RISC-V.

=== Инструментарий RISC-V

==== Знакомство с инструментами RISC-V

Одним из ключевых требований к использованию процессора является наличие чистой среды разработки с набором инструментов (называемых «инструментарий»),
которые позволят беспрепятственно использовать программное обеспечение на создаваемом оборудовании.
Сообщество RISC-V позаботилось о том, чтобы инструментарий программного обеспечения был хорошо построен и хорошо поддерживался,
чтобы разработчики могли быстро и легко использовать эти инструменты для разработки своего программного обеспечения и запуска его на аппаратном обеспечении.

Инструменты RISC-V можно получить с https://github.com/riscv-collab/riscv-gnu-toolchain[GitHub].
Процесс их установки подробно описан в файле `README`, размещенном в этом месте.
Пользователи Windows могут установить инструментарий в среде Cygwin или MinGW.

Список программного обеспечения, поддерживаемого на RISC-V, также доступен на https://github.com/riscvarchive/riscv-software-list[GitHub].
Это должно послужить хорошей отправной точкой для учащихся и разработчиков, начинающих использовать программные инструменты, которые не являются частью данного курса.

В этом курсе мы будем использовать компилятор GNU GCC C/{cpp} и компоновщик для компиляции и запуска программных приложений, которые мы разрабатываем на наших аппаратных моделях RISC-V.

Для разработки программного обеспечения под Windows/Linux/Mac мы можем использовать IDE на базе Eclipse или командную строку GCC.

==== Установка инструментария: на машинах Windows

Если вы планируете использовать Windows для отработки примеров, то для запуска примеров FreeRTOS можно использовать инструментарий Eclipse,
который был установлен в предыдущей главе.
После установки Eclipse выполните следующие шаги для установки инструментария RISC-V.

Доступ к инструментарию можно получить с помощью библиотеки xPack.
Для получения более подробной информации см. следующие два ресурса:

* https://gnu-mcu-eclipse.github.io/blog/2019/04/25/riscv-none-gcc-v8-2-0-2-1-20190425-released/[GNU MCU Eclipse RISC-V Embedded GCC v8.2.0-2.1 20190425 released]
* https://xpack.github.io/riscv-none-elf-gcc/install/[How to install the xPack GNU RISC-V Embedded GCC binaries]

===== Шаг 1:

Установите npm для Windows.
Это утилита, которая позволяет пользователям устанавливать пакеты Java.

===== Шаг 2:

После установки npm выполните следующую команду в утилите командной строки, чтобы установить основные программы, необходимые для установки инструментария:

[source,bash]
----
npm install --global xpm@latest
----

===== Шаг 3:

После установки XPM выполните приведенную ниже команду для установки компилятора GCC и сопутствующих инструментов:

[source,bash]
----
xpm install --global @xpack-dev-tools/riscv-none-embed-gcc@latest –verbose
----

==== Установка инструментария: на машинах Linux

На машинах Linux пользователи могут установить либо инструментарий на базе Eclipse, либо инструментарий командной строки.
Инструментарий командной строки может быть установлен из двоичных файлов, или пользователь может загрузить исходный код компилятора и скомпилировать его на своей машине.

Ниже описаны шаги для обоих методов установки инструментальной цепочки на Linux-машинах.

===== Установка двоичных файлов

====== Шаг 1:

Пользователь может загрузить двоичные файлы компилятора из следующего https://gitlab.com/shaktiproject/software[места на GitLab].

====== Шаг 2:

После клонирования двоичных файлов установите путь к директории `bin` инструмента, а также добавьте библиотечные файлы в `+LD_LIBRARY_PATH+`.

Пример настроек:

* `+export PATH=$PATH:$RISCV/bin:$RISCV/riscv32/bin:$RISCV/riscv64/bin+`

* `+export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$RISCV/riscv32/lib:$RISCV/riscv64/lib+`

===== Установка из исходного кода

Установка из исходного кода может быть выполнена путем получения исходных файлов из следующего
https://github.com/riscv-collab/riscv-gnu-toolchain[места на GitHub].

Выполните шаги, перечисленные в файле `README` на GitHub.
В результате инструменты будут установлены и готовы к использованию в вашей среде Linux.

==== Написание приложений для RISC-V

Поскольку кросс-компиляторы легко доступны для всех платформ, написание приложений для RISC-V не отличается от написания любой другой программы на языке Си.
При компиляции приложения пользователям, возможно, придется использовать соответствующие компиляторы Си для компиляции кода.
В этом случае для компиляции приложения пользователю необходимо использовать кросс-компилятор RISC-V для выбранной им машины.

После компиляции приложения пользователь может протестировать его с помощью различных эмуляторов, таких как Spike (специфичный для RISC-V) или QEMU (поддерживает несколько семейств процессоров).

Можно даже загрузить образ Linux на процессоре RISC-V с помощью инструмента эмуляции.
